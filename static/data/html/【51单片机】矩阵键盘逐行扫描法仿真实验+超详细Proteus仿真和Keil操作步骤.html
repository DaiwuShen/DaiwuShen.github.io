<meta name="description" content="author:DaiwuShen|date:2021-04-14|classification:计算机.单片机|tag:单片机,C语言,80C51|image:" />
<div class="alticle-title">
	<h1 id="_title1">【51单片机】矩阵键盘逐行扫描法仿真实验+超详细Proteus仿真和Keil操作步骤</h1>
</div>
<div class="alticle-detail">
	<div class="paragraph">
		<h2 id="_title1-1">一、环境</h2>
		<p>我用的是Keil5做编译工具，用proteus仿真。除了Keil5不知道有没有其他好用的能生成.hex文件的软件（要单片机运行是需要生成.hex文件的），Proteus则是一款很好用的仿真软件，原件很多。当然，之前有试过multisim14，也是非常不错的软件，自带有可以编写代码的文本编辑器，但没找到我想要的原件。所以选择了Proteus。
		</p>
		<h2 id="_title1-2">二、硬件部分</h2>
		<p>我们可以先打开Proteus：</p>
		<img loading="lazy"
			src="https://cdn.staticaly.com/gh/DaiwuShen/daiwuImageBed@main/20230310/daiwus-图片.6ofzjbtbuqo0.png"
			alt="proteus开始界面" />
		<h3 id="_title1-2-1">1. Proteus新建工程</h3>
		<p>点击开始界面的创建工程，先创建一个Proteus的工程。</p>
		<img loading="lazy"
			src="https://cdn.staticaly.com/gh/DaiwuShen/daiwuImageBed@main/20230310/daiwus-图片.7s5a0n00ens.png" alt="" />
		<p>（注意：最好每个项目单独一个文件夹，后期的文件很乱很杂）。工程名写好，选择好文件夹，后面的可以一直下一步。</p>
		<h3 id="_title1-2-2">2. 添加元件</h3>
		<img loading="lazy"
			src="https://cdn.staticaly.com/gh/DaiwuShen/daiwuImageBed@main/20230310/daiwus-图片.2c2lplnwufpc.png"
			alt="" />
		<p>可以直接点红色箭头或者先点击“元件模式”然后点击“P”进入元件库。</p>
		<img loading="lazy"
			src="https://cdn.staticaly.com/gh/DaiwuShen/daiwuImageBed@main/20230310/daiwus-图片.iw7esyoinqo.png" alt="" />
		<p>可以输入80C51进行筛选，我用的是第一个<span>80C51</span>。<br>
			再找到筛选keypad，我用的是<span>keypad-smallcalc</span>。<br>
			接着找LED，选择的是<span>LED-BARGRAPH-GRN</span>，作为输出，也方便调试。</p>
		<img loading="lazy"
			src="https://cdn.staticaly.com/gh/DaiwuShen/daiwuImageBed@main/20230310/daiwus-图片.blsrvz74myo.png" alt="" />
		<p>选好的元件就在这了。然后点击就能放置元件。</p>
		<img loading="lazy"
			src="https://cdn.staticaly.com/gh/DaiwuShen/daiwuImageBed@main/20230310/daiwus-图片.1ouu9fz1i8bk.png"
			alt="" />
		<h3 id="_title1-2-3">3.连接线路</h3>
		<img loading="lazy"
			src="https://cdn.staticaly.com/gh/DaiwuShen/daiwuImageBed@main/20230310/daiwus-图片.6a4j0dtgu2v4.png"
			alt="" />
		<h3 id="_title1-2-4">4、硬件效果</h3>
		<p>当然，红色和蓝色的点不是接上线就有的，这是仿真之后的效果。其中，<span><strong>红色是高电平，蓝色是低电平，无色是无电平或脉冲不稳定，黄色为短路。</strong></span><br>
			注意：Proteus的部分原件默认接了电源和接地，所以找不到电源和接地管脚。比如T80C51就是默认了接电源接地，所以没有20、40管脚。</p>
		<h2 id="_title1-3">三、软件部分</h2>
		<p>刚刚完成了硬件部分，和真实的硬件一样，我们都需要有程序才能让单片机工作。现在我们来用Keil5编写程序。虽然课程是用的汇编，但由于个人不太习惯汇编的程序，所以我尝试的是C语言。目标是做成一个<strong>简单的计算器</strong>。
		</p>
		<h3 id="_title1-3-1">1、Keil5新建工程</h3>
		<p>菜单栏的<strong>project</strong>下的<strong>new uVision
				project</strong>，选择好芯片<strong>T80C51</strong>，选择好地址
			（可以和Proteus的工程放一个文件夹）。<br>
			然后新建一个.c源文件，并把源文件添加到工程的 <strong>Source Group</strong>内。</p>
		<h3 id="_title1-3-2">2、代码：</h3>
		<h4>（1 思路分析</h4>
		<p>想要做一个计算器，其中有“+、-、*、/ ”
			。最开始我想到的是数字和运算符分开存放，然后再处理。后来发现无法预测输入的数字位数（因为每次只能输入一位，也不能像在黑窗口那样回车）。于是我决定把数字变成字符，跟运算符存放在一个<span>char数列</span>里，再分析处理数列，找出数字和运算符。
		</p>
		<h4>（2 添加头文件</h4>
		<p>添加头文件，并设置全局变量。</p>
		<pre data-index="0">
	  <div class="hljs-ln-numbers line-number"><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p></div>
	  <code>#include &ltreg51.h&gt
int cro[4] = {0xFE,0xFD,0xFB,0xF7};//存放行值。分别表示是P2.0口低电平，P2.1低电平…………
char indata[50];//用于存放键盘输入的字符数列
int len=0;//数列的长度
int fnum=0;//用于存放第一个操作数（处理数列得到的数字）
int lnum=0;//用于存放第二个操作数（处理数字得到的数字）
int ans=0;//存放计算结果
char op;//存放运算符</code></pre>
		<p>这是51单片机的头文件，里面包含了51单片机的<strong>存储器、端口</strong>等</p>
		<h4>（3 延时程序</h4>
		<p>在单片机中延时程序经常用到，延时的方法也很多，有<strong>硬件延时、软件延时</strong>，汇编中可能会用<strong>nop</strong>，或者
		</p>
		<pre>
	  <div class="hljs-ln-numbers line-number">
		<p>1</p>
		<p>2</p>
	  </div>
	  <code>MOV R0,100
DJNZ R0,$</code></pre>
		<p>在C语言中可以通过空循环来延时，就像下面这样。当然也有其他方法。</p>
		<pre>
	  <div class="hljs-ln-numbers line-number">
		<p>1</p>
		<p>2</p>
		<p>3</p>
		<p>4</p>
	  </div>
	  <code>void delay_ms(int n){
	int i,j;
	for(i = 0; i &lt n; i++)
	for(j = 0; j &lt 1000; j++);}//这里的值只是大概写的，n==1时不一定真是1ms。也可以算准确值。</code></pre>
		<p>如果一个循环够用或者容易控制时间的话，可以不用嵌套。</p>
		<h4>（4 键盘扫描程序</h4>
		<p>最先尝试的是矩阵键盘的<strong>线路反转法</strong>，但是中间出了些问题，暂时放弃了，改用<strong>逐行扫描法</strong>。
			根据书上的原理，结合以上面的电路图 写出程序。</p>
		<img loading="lazy"
			src="https://cdn.staticaly.com/gh/DaiwuShen/daiwuImageBed@main/20230310/daiwus-图片.6a4j0dtgu2v4.png"
			alt="" />
		<p>可见，我们的<strong>键盘连接了P2端口，低4位为行，高四位为列，LED则连接的P1端口</strong>。以此为例。<br>
			<strong>先使行端口（即P2端口低四位）输出低电平，读列值</strong>。若读入的列值不为<strong>0FFH</strong>，则有键按下
		</p>
		<pre>
	  <div class="hljs-ln-numbers line-number">
		<p>1</p>
		<p>2</p>
		<p>3</p>
		<p>4</p>
	  </div>
	  <code>int keyscan(){
	int temp;
	P2 = 0xf0;//给P12口送入11110000B
	temp = P2 & 0xf0;}//读取列值</code></pre>
		<p><strong>注意：在C语言里，二进制是前面加0b或0B，八进制是加0，十六进制加0x或0X</strong>。如十进制123，二进制0b123或0B123，八进制0123，十六进制0x123或0X123。<br>
			这样就能完成<strong>行输出低电平，读取列值</strong>的操作。如果列值不为0xf0，表示有键按下，有一位变成低电平。<br>
			当有键按下时，可以<strong>加10毫秒延时去抖</strong>。再进行逐行扫描。<br>
			扫描的过程是第四位逐位输出低电平，读不为0xff 的列值</p>
		<pre>
	  <div class="hljs-ln-numbers line-number">
		<p>1</p>
		<p>2</p>
		<p>3</p>
		<p>4</p>
		<p>5</p>
		<p>6</p>
		<p>7</p>
		<p>8</p>
		<p>9</p>
		<p>10</p>
		<p>11</p>
		<p>12</p>
		<p>13</p>
		<p>14</p>
	  </div>
	  <code>int keyscan(){
	int n;
	int row;
	int temp;
	P2 = 0xf0;
	temp = P2 & 0xf0;
	if(temp != 0xf0){
		delay_ms(10)//这里需要加10毫秒延时去抖，
		for(n = 0; n &lt 4; n++ ){//遍历，低4位逐位输出0，直到找到按下键的列值
		    P2 = cro[n];//P2口低位输出0
		    rol = P2 & 0xf0;//读高四维
		    if(rol != 0xf0){
		        return (row|(cro[n]&0x0f));//找到按下键的列值后合成键码，并返回
		        break;}}}}</code></pre>
		<p>这就是<span>逐行扫描</span>的主要程序。</p>
		<h4>（5 配置按键功能</h4>
		<p>这时候我们发现，键码找对了，该怎么让它执行特定的程序呢？比如现在按"1"，它并不代表"1"这个数。这个时候我们就需要给键配置一个功能或者含义。<br>
			我是这样定义的：</p>
		<pre>
	  <div class="hljs-ln-numbers line-number">
		<p>1</p>
		<p>2</p>
		<p>3</p>
		<p>4</p>
		<p>5</p>
		<p>6</p>
		<p>7</p>
		<p>8</p>
	  </div>
	  <code>void act(int key){
	switch(key){
		case 0x77:indata[len++] = '+';P1 = 0x80;break;//输入的是运算符，输出运算符按键对应的行。并存放到前面定义的数组里，长度＋1
		case 0xB7: show();	break;//”=“键的功能是展示运算结果
		case 0xD7:indata[len++] = '0';P1 = 0x00;break;//输入的是数字，输出对应的二进制数
		case 0xE7:clear();	break;//清零键的功能是清零
		case 0x7B:indata[len++] = '-';P1 = 0x40;break;
		case 0xBB:indata[len++] = '3';P1 = 0x03;break;
		case 0xDB:indata[len++] = '2';P1 = 0x02;break;
		case 0xEB:indata[len++] = '1';P1 = 0x01;break;
		case 0x7D:indata[len++] = '*';P1 = 0x20;break;
		case 0xBD:indata[len++] = '6';P1 = 0x06;break;
		case 0xDD:indata[len++] = '5';P1 = 0x05;break;
		case 0xED:indata[len++] = '4';P1 = 0x04;break;
		case 0x7E:indata[len++] = '/';P1 = 0x10;break;
		case 0xBE:indata[len++] = '9';P1 = 0x09;break;
		case 0xDE:indata[len++] = '8';P1 = 0x08;break;
		case 0xEE:indata[len++] = '7';P1 = 0x07;break;
		default:break;}}</code></pre>
		<p>到这里我们的基本要求已经完成。接下来是完善的部分。</p>
		<h4>（6 补坑</h4>
		<p>刚才用到而没有定义的函数，<span>show（）clear（）</span>。现在就让我们来把这两个函数写出来。<br>
			首先是"="号键的功能函数show（）</p>
		<pre>
	  <div class="hljs-ln-numbers line-number">
		<p>1</p>
		<p>2</p>
		<p>3</p>
		<p>4</p>
	  </div>
	  <code>void show(){
	decode();//这是一个把存放按键的字符数组变成可以运算的数字的函数。
	operat();//把字符型的数字变成int型的数字后，就该计算了。这是运算函数。
	P1 = ans;}//最终要把运算结果输出到LED。由于之前定义的是全局变量，所以不需要传参数</code></pre>
		<p>接下来是清零按键的功能，清零。</p>
		<pre>
	  <div class="hljs-ln-numbers line-number">
		<p>1</p>
		<p>2</p>
		<p>3</p>
		<p>4</p>
		<p>5</p>
		<p>6</p>
		<p>7</p>
		<p>8</p>
	  </div>
	  <code>void clear(){
	int i;
	for(i=0;i&ltlen;i++){//清空数组。数组没清空可能会影响第二次计算。
		indata[i] = '\0';}
	len=0;
	fnum=0;
	lnum=0;
	ans=0;
	op = '\0';
	for(i=0;i&lt3;i++){//LED闪烁三次，作为提醒。
		P1 = 0xff;
		delay_ms(20);
		P1 = 0x00;
		delay_ms(20);}}</code></pre>
		<h4>（7 深度补坑</h4>
		<p>前面的确做到了按哪个键输出对应的值。但是！！！我们怎么会满足于此呢？说好的计算器呢？<br>
			对！下面就来把运算功能的坑填一填。<br>
			首先是把字符数组的数据变成可以数学运算的数字。</p>
		<pre>
	  <div class="hljs-ln-numbers line-number">
		<p>1</p>
		<p>2</p>
		<p>3</p>
		<p>4</p>
		<p>5</p>
		<p>6</p>
		<p>7</p>
		<p>8</p>
	  </div>
	  <code>void decode(){
	int i;
	int j;
	for(i = 0; i &lt len;i++){//先找到第一个数
		if(indata[i] >= '0' && indata[i] <= '9')
			fnum = fnum*10 + (indata[i]-'0');
		else	break;}
	if(indata[i] == '+' || indata[i]=='-'||indata[i]=='*'||indata[i]=='/'){//然后找到中间的运算符
		op = indata[i];i++;}
	for(j = i; j &lt len;j++){//再找到第二个操作数。
		lnum = lnum*10 + (indata[j]-'0');}}</code>
	</pre>
		<p>是不是so easy?确实，都是基础。可能我的算法还不够好。暂且这么看着吧，提供一个思路。<br>
			然后，然后的然后就是该运算了。这个也非常简单，用一个多分支语句就能搞定了。</p>
		<pre>
	  <div class="hljs-ln-numbers line-number">
		<p>1</p>
		<p>2</p>
		<p>3</p>
		<p>4</p>
		<p>5</p>
		<p>6</p>
	  </div>
	  <code>void operat(){
	switch(op){
		case '+':ans = fnum + lnum;break;
		case '-':ans = fnum - lnum;break;
		case '*':ans = fnum * lnum;break;
		case '/':ans = fnum / lnum;break;}}</code>
	</pre>
		<p>这样就能实现运算功能了</p>
		<h4>（8 程序入口</h4>
		<p>最后我们只差一个程序入口函数了。把main() 函数加进去我们的程序就大功告成了。</p>
		<pre>
	  <div class="hljs-ln-numbers line-number">
		<p>1</p>
		<p>2</p>
		<p>3</p>
		<p>4</p>
	  </div>
	  <code>void main(){
	while(1){
		act(keyscan());
		delay_ms(70);}}</code></pre>
		<p>以上就是我编写时的思路和实现。</p>
		<h2 id="_title1-4">四、让程序跑起来</h2>
		<p>现在我们硬件搭建好了，软件也实现了，接下来就是让软件在硬件中跑起来。</p>
		<h3 id="_title1-4-1">1、生成.hex文件</h3>
		<img loading="lazy"
			src="https://cdn.staticaly.com/gh/DaiwuShen/daiwuImageBed@main/20230310/daiwus-图片.3n84esawrd8g.png"
			alt="" />
		<p>先点击这个<strong>"Option for target"</strong>。</p>
		<img loading="lazy"
			src="https://cdn.staticaly.com/gh/DaiwuShen/daiwuImageBed@main/20230310/daiwus-图片.7g8ktjc98s1s.png"
			alt="" />
		<p>然后找到<span>"Output"</span>里的<span>"Creat HEX
				File"</span>，把复选框勾上，然后编译的时候就能生成.hex文件。<br>
			当然，这个文件也可能生成在"Object"文件夹里。<br>
			记住.hex文件的地址。</p>
		<h3 id="_title1-4-2">2、单片机添加程序文件</h3>
		<p>在Proteus中双击51单片机，进入单片机的属性窗口</p>
		<img loading="lazy"
			src="https://cdn.staticaly.com/gh/DaiwuShen/daiwuImageBed@main/20230310/daiwus-图片.3ugybyax8a9s.png"
			alt="" />
		<p>点击<span>"ProgramFile"</span>后面的框选择文件，把刚才得到的.hex文件添加进去。点击左下角的开始仿真按键就可以试试自己写的程序的运行效果了。
		</p>
		<img loading="lazy"
			src="https://cdn.staticaly.com/gh/DaiwuShen/daiwuImageBed@main/20230310/daiwus-20210414210351386.5u7yk0luy1s0.gif"
			alt="" />
		<p>输入了12 * 2 ，输出的是11000B，即24D；按下清零，LED闪烁提醒。功能基本实现。</p>
		<h2 id="_title1-5">五、 总结</h2>
		<p>这次时第一次用C写单片机，先前学的C似乎又能发挥作用了。但是没目前这个程序还是比较粗糙，可以再改进一下，比如可以做个连续运算的计算器，或者增加其他不一样的功能，包括多义键，以及输出设备LED也可以优化。<br>
			在这个过程中，我也发现自己的算法比较朴实无华，都是些常规的逻辑。希望有其他的做法的小伙伴一起讨论。</p>
	</div>
</div>